/*
 * This software is licensed under the terms of the MIT-License
 * See COPYING for further information. 
 * ---
 * Copyright (C) 2011, Lukas Weber <laochailan@web.de>
 * Copyright (C) 2011, Alexeyew Andrew <https://github.com/nexAkari>
 */

#include <stdio.h>
#include "menu.h"
#include "options.h"
#include "global.h"

void do_nothing(void *arg) { }
void backtomain(void *arg)
{
	MenuData *m = arg;
	m->quit = 2;
}

void allocate_bindings(MenuData *m)
{
	OptionBinding *binds = malloc(m->ecount * sizeof(OptionBinding));
	int i;
	
	for(i = 0; i < m->ecount; ++i)
	{
		binds[i].values 	 = NULL;
		binds[i].getter		 = NULL;
		binds[i].setter 	 = NULL;
		binds[i].selected 	 = -1;
		binds[i].valcount	 = 0;
		binds[i].configentry = -1;
		binds[i].enabled	 = False;
	}
	
	m->context = (void*)binds;
}

void free_bindings(MenuData *m)
{
	OptionBinding *binds = (OptionBinding*)m->context;
	
	int i, j;
	for(i = 0; i < m->ecount; ++i)
	{
		OptionBinding *bind = &(binds[i]);
		if(!bind->enabled)
			continue;
		
		if(bind->values) for(j = 0; j < bind->valcount; ++j)
			free(bind->values[j]);
		free(bind->optname);
	}
	free(binds);
}

void menu_save_config(MenuData *m, char *filename)
{
	char *buf;
	buf = malloc(strlen((char*)filename)+strlen((char*)get_config_path())+3);	
	strcpy(buf, (char*)get_config_path());
	strcat(buf, "/");
	strcat(buf, filename);
	
	FILE *out = fopen(buf, "w");
	free(buf);
	
	if(!out)
	{
		perror("fopen");
		return;
	}
	
	fputs("# Generated by taisei\n", out);
	
	int i;
	for(i = 0; i < m->ecount; ++i)
	{
		OptionBinding *binds = (OptionBinding*)m->context;
		OptionBinding *bind = &(binds[i]);
		
		if(!bind->enabled)
			continue;
		
		switch(bind->type)
		{
			case BT_IntValue:
				fprintf(out, "%s = %i\n", bind->optname, tconfig.intval[bind->configentry]);
				break;
			
			case BT_KeyBinding:
				fprintf(out, "%s = K%i # SDL key name: %s\n", bind->optname, tconfig.intval[bind->configentry],
																			 SDL_GetKeyName(tconfig.intval[bind->configentry]));
				break;
			
			default:
				printf("FIXME: unhandled BindingType %i, option '%s' will NOT be saved!\n", bind->type, bind->optname);
		}
	}
	
	printf("Saved config '%s'\n", filename);
}

void options_menu_destroy(void *menu)
{
	MenuData *m = (MenuData*)menu;
	menu_save_config(m, CONFIG_FILE);
	free_bindings(menu);
}

OptionBinding* bind_option_to_entry(MenuData *m, int entry, char *optname, int cfgentry, BindingGetter getter, BindingSetter setter)
{
	OptionBinding *binds = (OptionBinding*)m->context;
	OptionBinding *bind = &(binds[entry]);
	
	bind->getter = getter;
	bind->setter = setter;
	bind->configentry = cfgentry;
	bind->optname = malloc((strlen(optname) + 1) * sizeof(char));
	strcpy(bind->optname, optname);
	bind->enabled = True;
	bind->type = BT_IntValue;
	
	return bind;
}

OptionBinding* bind_keybinding_to_entry(MenuData *m, int entry, char *optname, int cfgentry)
{
	OptionBinding *binds = (OptionBinding*)m->context;
	OptionBinding *bind = &(binds[entry]);
	
	bind->configentry = cfgentry;
	bind->optname = malloc((strlen(optname) + 1) * sizeof(char));
	strcpy(bind->optname, optname);
	bind->enabled = True;
	bind->type = BT_KeyBinding;
	
	return bind;
}

int bind_addvalue(OptionBinding *b, char *val)
{
	if(!b->values)
		b->values = malloc(++b->valcount * sizeof(char));
	else
		b->values = realloc(b->values, ++b->valcount * sizeof(char));
	
	b->values[b->valcount-1] = malloc((strlen(val) + 1) * sizeof(char));
	strcpy(b->values[b->valcount-1], val);
	return b->valcount-1;
}

int binding_setvalue(OptionBinding *b, int v)
{
	return b->selected = b->setter(b, v);
}

int binding_setnext(OptionBinding *b)
{
	int s = b->selected + 1;
	if(s >= b->valcount)
		s = 0;
		
	return binding_setvalue(b, s);
}

int binding_setprev(OptionBinding *b)
{
	int s = b->selected - 1;
	if(s < 0)
		s = b->valcount - 1;
		
	return binding_setvalue(b, s);
}

void bindings_initvalues(MenuData *m)
{
	OptionBinding *binds = (OptionBinding*)m->context;
	
	int i;
	for(i = 0; i < m->ecount; ++i)
		if(binds[i].enabled && binds[i].type == BT_IntValue)
			binds[i].selected = binds[i].getter(&(binds[i]));
}

int bind_common_onoffget(void *b)
{
	return !tconfig.intval[((OptionBinding*)b)->configentry];
}

int bind_common_onoffset(void *b, int v)
{
	return !(tconfig.intval[((OptionBinding*)b)->configentry] = !v);
}

int bind_common_onoffget_inverted(void *b)
{
	return tconfig.intval[((OptionBinding*)b)->configentry];
}

int bind_common_onoffset_inverted(void *b, int v)
{
	return tconfig.intval[((OptionBinding*)b)->configentry] = v;
}

int bind_fullscreen_set(void *b, int v)
{
	toggle_fullscreen();
	return bind_common_onoffset(b, v);
}

int bind_noaudio_set(void *b, int v)
{
	int i = bind_common_onoffset_inverted(b, v);
	
	if(!v)
	{
		init_alut();
		load_resources();
	}
	
	return i;
}

int bind_noshader_set(void *b, int v)
{
	int i = bind_common_onoffset_inverted(b, v);
	
	if(!v)
	{
		_init_fbo();
		load_resources();
	}
	
	return i;
}

#define bind_onoff(b) bind_addvalue(b, "on"); bind_addvalue(b, "off")

void create_options_menu(MenuData *m) {
	OptionBinding* b;
	
	create_menu(m);
	m->type = MT_Persistent;
	m->ondestroy = options_menu_destroy;
	
	add_menu_entry(m, "Fullscreen", do_nothing, NULL);	// entry 0
	add_menu_entry(m, "Audio", do_nothing, NULL);
	add_menu_entry(m, "Shader", do_nothing, NULL);
	add_menu_entry(m, " ", NULL, NULL);
	add_menu_entry(m, "Move up", do_nothing, NULL); // entry 4
	add_menu_entry(m, "Move down", do_nothing, NULL);
	add_menu_entry(m, "Move left", do_nothing, NULL);
	add_menu_entry(m, "Move right", do_nothing, NULL);
	add_menu_entry(m, " ", NULL, NULL);
	add_menu_entry(m, "Fire", do_nothing, NULL); // entry 9
	add_menu_entry(m, "Focus", do_nothing, NULL);
	add_menu_entry(m, "Bomb", do_nothing, NULL);
	add_menu_entry(m, " ", NULL, NULL);
	add_menu_entry(m, "Toggle fullscreen", do_nothing, NULL); // entry 13
	// UNCOMMENT after akari/screenshot is merged
	//add_menu_entry(m, "Take a screenshot", do_nothing, NULL);
	add_menu_entry(m, " ", NULL, NULL);
	//add_menu_entry(m, "Customize controls", NULL, NULL);
	add_menu_entry(m, "Return to the main menu", backtomain, m);
	
	allocate_bindings(m);
	
	// this sucks but you have to specify the positional number of the menu entry as the second argument to bind_option_to_entry or bind_keybinding_to_entry
	
	b = bind_option_to_entry(m, 0, "fullscreen", FULLSCREEN, bind_common_onoffget, bind_fullscreen_set);
		bind_onoff(b);
	
	b = bind_option_to_entry(m, 1, "disable_audio", NO_AUDIO, bind_common_onoffget_inverted,
															  bind_noaudio_set);
		bind_onoff(b);
	
	b = bind_option_to_entry(m, 2, "disable_shader", NO_SHADER, bind_common_onoffget_inverted,
																bind_noshader_set);
		bind_onoff(b);
	
	bind_keybinding_to_entry(m, 4, "key_up", KEY_UP);
	bind_keybinding_to_entry(m, 5, "key_down", KEY_DOWN);
	bind_keybinding_to_entry(m, 6, "key_left", KEY_LEFT);
	bind_keybinding_to_entry(m, 7, "key_right", KEY_RIGHT);
	
	bind_keybinding_to_entry(m, 9, "key_shot", KEY_SHOT);
	bind_keybinding_to_entry(m, 10, "key_focus", KEY_FOCUS);
	bind_keybinding_to_entry(m, 11, "key_bomb", KEY_BOMB);
	
	bind_keybinding_to_entry(m, 13, "key_fullscreen", KEY_FULLSCREEN);
	// UNCOMMENT after akari/screeenshot is merged
	//bind_keybinding_to_entry(m, 14, "key_screenshot", KEY_SCREENSHOT);
	
	bindings_initvalues(m);
}

void draw_options_menu_bg(MenuData* menu) {
	glColor4f(0.3, 0.3, 0.3, 1);
	draw_texture(SCREEN_W/2, SCREEN_H/2, "mainmenu/mainmenubgbg");
	glColor4f(1,0.6,0.5,0.6 + 0.1*sin(menu->frames/100.0));
	draw_texture(SCREEN_W/2, SCREEN_H/2, "mainmenu/mainmenubg");
}

void draw_options_menu(MenuData *menu) {
	draw_options_menu_bg(menu);
	glColor4f(1,1,1,1);
	draw_text(AL_Right, 140*(1-menu->fade), 30, "Options", _fonts.mainmenu);
	
	//glColor4f(1,1,1,0.7);
	//draw_texture(SCREEN_W/2+40, SCREEN_H/2, "mainmenu/gate");
	
	glPushMatrix();
	glTranslatef(100, 100, 0);
	
	glPushMatrix();
	glTranslatef(0, menu->drawdata[2], 0);
	glColor4f(0,0,0,0.5);
	glBegin(GL_QUADS);
		glVertex3f(0, -10, 0);
		glVertex3f(0,  10, 0);
		glVertex3f(SCREEN_W - 200,  10, 0);
		glVertex3f(SCREEN_W - 200, -10, 0);
	glEnd();
	glPopMatrix();
	
	OptionBinding *binds = (OptionBinding*)menu->context;
	OptionBinding *bind;
	int i;

	for(i = 0; i < menu->ecount; i++) {
		float s = 0;
		
		if(menu->entries[i].action == NULL)
			glColor4f(0.5, 0.5, 0.5, 0.7);
		else if(i == menu->cursor)
		{
			glColor4f(1,1,0,0.7);
			s = 5*sin(menu->frames/80.0 + 20*i);
		}
		else
			glColor4f(1, 1, 1, 0.7);

		draw_text(AL_Left, 20 + s, 20*i, menu->entries[i].name, _fonts.standard);
		
		bind = &(binds[i]);
		
		if(bind->enabled)
		{
			int j, origin = SCREEN_W - 220;
			switch(bind->type)
			{
				case BT_IntValue:
					for(j = bind->valcount-1; j+1; --j)
					{
						if(j != bind->valcount-1)
							origin -= strlen(bind->values[j+1])/2.0 * 20;
						
						if(bind->selected == j)
							glColor4f(1,1,0,0.7);
						else
							glColor4f(0.5,0.5,0.5,0.7);
							
						draw_text(AL_Right, origin, 20*i, bind->values[j], _fonts.standard);
					}
					break;
				
				case BT_KeyBinding:
					draw_text(AL_Right, origin, 20*i, SDL_GetKeyName(tconfig.intval[bind->configentry]), _fonts.standard);
					break;
			}
		}
	}
	
	
	glPopMatrix();
	menu->drawdata[2] += (20*menu->cursor - menu->drawdata[2])/10.0;
	
	fade_out(menu->fade);
	
	glColor4f(1,1,1,1);	
}

void options_menu_input(MenuData *menu) {
	SDL_Event event;
	
	// REMOVE after akari/screenshot is merged
	global_input();
	
	while(SDL_PollEvent(&event)) {
		int sym = event.key.keysym.sym;
		
		// UNCOMMENT after akari/screenshot is merged
		//global_processevent(&event);
		if(event.type == SDL_KEYDOWN) {
			if(sym == tconfig.intval[KEY_DOWN]) {
				menu->drawdata[3] = 10;
				while(!menu->entries[++menu->cursor].action);
				
				if(menu->cursor >= menu->ecount)
					menu->cursor = 0;
				
			} else if(sym == tconfig.intval[KEY_UP]) {
				menu->drawdata[3] = 10;
				while(!menu->entries[--menu->cursor].action);
				
				if(menu->cursor < 0)
					menu->cursor = menu->ecount - 1;
				
			} else if((sym == tconfig.intval[KEY_SHOT] || sym == SDLK_RETURN) && menu->entries[menu->cursor].action) {
				menu->selected = menu->cursor;
				
				OptionBinding *binds = (OptionBinding*)menu->context;
				OptionBinding *bind = &(binds[menu->selected]);
				
				if(bind->enabled) switch(bind->type)
				{
					case BT_IntValue: binding_setnext(bind); break;
				}
				else
					menu->quit = 1;
			} else if(sym == tconfig.intval[KEY_LEFT]) {
				menu->selected = menu->cursor;
				OptionBinding *binds = (OptionBinding*)menu->context;
				OptionBinding *bind = &(binds[menu->selected]);
				
				if(bind->enabled && bind->type == BT_IntValue)
					binding_setprev(bind);
			} else if(sym == tconfig.intval[KEY_RIGHT]) {
				menu->selected = menu->cursor;
				OptionBinding *binds = (OptionBinding*)menu->context;
				OptionBinding *bind = &(binds[menu->selected]);
				
				if(bind->enabled && bind->type == BT_IntValue)
					binding_setnext(bind);
			} else if(sym == SDLK_ESCAPE) {
				menu->quit = 2;
			}
			
			menu->cursor = (menu->cursor % menu->ecount) + menu->ecount*(menu->cursor < 0);
		} else if(event.type == SDL_QUIT) {
			exit(1);
		}
	}
}

int options_menu_loop(MenuData *menu) {
	return menu_loop(menu, options_menu_input, draw_options_menu);
}

